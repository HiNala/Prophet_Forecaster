# **Phase 2 Document: GUI Plan**

In this **Phase 2** document, we will outline a **desktop GUI** approach that integrates seamlessly with the **CLI-based forecasting tool** described in the Phase 1 plan. Although our underlying application supports browser-based visualizations (for interactive charts and dashboards), this GUI will **not be a web application**. Instead, it will be a **native desktop application** (e.g., using PyQt, Tkinter, or another Python GUI framework) that will launch and manage the existing CLI workflow under the hood, while also displaying HTML-based visualizations in an embedded widget or an external browser window if desired.

---

## **1. High-Level Objectives**

1. **Professional Look & Feel**  
   - Use a modern and well-supported Python GUI toolkit (e.g., **PyQt5** or **PyQt6**, **PySide2** or **PySide6**, or **Tkinter** with themed widgets).
   - Provide a clean, user-friendly interface that mirrors the CLI’s functionality.

2. **Seamless Integration with CLI Modules**  
   - The GUI should trigger the same functions as the CLI (data ingestion, cleaning, indicators, training, forecasting, evaluation) through the **`main.py`** controller or direct calls to the respective module functions.
   - Results and logs from each step should be displayed or stored for easy reference.

3. **Embedded or External Visualization**  
   - The user can view advanced visuals (Plotly/Bokeh) within the GUI if the chosen framework supports an **HTML rendering widget**.
   - Alternatively, the GUI can open the generated HTML report in the user’s default web browser, maintaining a consistent flow.

---

## **2. Proposed GUI Framework**

### **2.1 Why PyQt (or PySide)**
- **Cross-Platform**: Works on Windows, macOS, and Linux.
- **Rich Widgets**: Offers a wide range of UI components (buttons, tables, progress bars, etc.) for a polished look.
- **HTML Rendering**: PyQt’s `QWebEngineView` (or `QWebView` in older versions) can render HTML, JavaScript, Plotly, or Bokeh outputs in a local window.
- **Scalable**: Can be extended with complex UI logic or multiple windows if needed.

*(If you prefer Tkinter or another framework, the overall plan remains similar; only the widget references change.)*

---

## **3. GUI Architecture**

```
+-----------------------+         +-------------------------+             
|       main.py         |         |   Additional Modules   |             
| (Controls all phases) |         | (data_ingestion, etc.) |             
+---------+-------------+         +-----------+-------------+             
          |                                 |                           
          | Calls GUI Launcher             |                           
          |                                 |                           
+---------v-------------+         +-------------------------+             
|    GUI Application    |  <-->   |  CLI-based Logic/Funcs  |  <---> Data 
| (PyQt/PySide/Tkinter) |         | (Inside *.py modules)   |             
+-----------------------+         +-------------------------+             
```

1. **`main.py`** (Phase 1)  
   - Continues to orchestrate the pipeline.  
   - **Adds** a method to launch the GUI instead of (or in addition to) the CLI-based flow.

2. **`gui.py`** (New File)  
   - Contains **PyQt/PySide** (or other) code for constructing the main window.  
   - Will have references to the underlying modules (`data_ingestion.py`, `data_cleaning.py`, etc.) or the high-level functions in `main.py`.

3. **Interaction Flow**  
   - The user starts `main.py`.  
   - **Option A**: If the user wants CLI, they can pass CLI arguments (unchanged from Phase 1).  
   - **Option B**: If the user wants GUI, they run something like `python main.py --gui` or select a “Launch GUI” option.  
   - The GUI then calls the exact same module functions used by the CLI commands, ensuring consistency.

---

## **4. GUI Layout**

### **4.1 Main Window Structure**

1. **Menu or Tabbed Interface**  
   - **Tabs** or **menu items** for each major phase:  
     - **Data** (Load, Preview)  
     - **Clean** (Missing Values, Outliers)  
     - **Indicators** (Apply SMA, RSI, etc.)  
     - **Train** (Prophet params, progress bar)  
     - **Forecast** (Future periods, output path)  
     - **Evaluate** (Cross-validation, metrics)

2. **Status/Log Panel**  
   - A console-like text area at the bottom or side to display logs and warnings generated by the modules.  
   - This mirrors the CLI’s printed output but provides a GUI-friendly view.

3. **Action Buttons**  
   - Each tab or section has **“Run”** or **“Execute”** buttons that trigger the appropriate workflow step.

4. **HTML Visualization Pane**  
   - If using PyQt/PySide, embed a `QWebEngineView` to display interactive charts.  
   - Alternatively, open an external browser tab showing the generated HTML.  
   - Provide a “Refresh” or “Reload” button to re-display new charts after each phase.

---

### **4.2 Example Tab/Window Breakdown**

1. **Data (Load & Preview)**  
   - **File Path**: Text box + “Browse…” button  
   - **Datetime Col / Target Col**: Text fields or dropdown (auto-detected if possible)  
   - **Preview Table**: Display first 5–10 rows of the DataFrame  

2. **Clean & Prepare**  
   - **Missing Value Handling**: Dropdown for “drop”, “interpolate”, etc.  
   - **Outlier Handling**: Dropdown for “zscore”, “iqr”, “none”  
   - **Apply Cleaning** button + optional summary table/plot  

3. **Indicators**  
   - **Selectable Indicators** (CheckBox or multi-select list: SMA, EMA, RSI, MACD, etc.)  
   - **Apply** button: calls `apply_indicators()`, then updates a small preview or summary  

4. **Train**  
   - **Prophet Parameters**:  
     - Seasonality mode (Additive/Multiplicative)  
     - Daily/Weekly/Yearly toggles  
   - **Train** button:  
     - Shows a **progress bar** or animation while `train_prophet_model()` runs  
     - Displays training logs in the status panel  

5. **Forecast**  
   - **Forecast horizon** (number of days/weeks)  
   - **Generate** button:  
     - Calls `generate_forecast()`  
     - Renders or opens the `forecast.html` (Plotly/Bokeh) in the embedded `QWebEngineView` or an external browser  

6. **Evaluate**  
   - **Cross-validation** settings (initial, period, horizon)  
   - **Evaluate** button:  
     - Calls `evaluate_model()`  
     - Shows metrics (e.g., MAPE, MAE, RMSE) in a table or text box  
     - Optionally displays a diagnostic chart

---

## **5. Detailed GUI Flow**

1. **User Launches the Application**  
   ```bash
   python main.py --gui
   ```
   - `main.py` detects the `--gui` flag and imports/initializes the GUI (e.g., `from gui import start_gui`).

2. **Main Window Loads**  
   - Displays the tabbed (or multi-window) interface.  
   - The user navigates to **Data** tab first.

3. **Data Ingestion**  
   - The user specifies file path, datetime column, target column, and clicks **Load**.  
   - The GUI calls a function (e.g., `load_data(...)`) from `data_ingestion.py`.  
   - Any warnings or logs are shown in the status/log area.

4. **Data Cleaning**  
   - The user chooses a missing value and outlier method, then clicks **Clean**.  
   - The GUI calls `handle_missing_values()` and `handle_outliers()` from `data_cleaning.py`.  
   - Updated data is stored in memory for subsequent steps.

5. **Indicators**  
   - The user checks “SMA” or “RSI” from the list and clicks **Apply**.  
   - The GUI calls `apply_indicators(...)` from `technical_indicators.py`.  
   - A small embedded plot or a separate “Preview” button can show the new columns.

6. **Model Training**  
   - The user sets Prophet parameters, clicks **Train**.  
   - The GUI calls `configure_prophet(...)`, `add_extra_regressors(...)`, and then `train_prophet_model(...)`.  
   - A progress bar or spinner shows training status.  
   - Logs (including warnings or training time) go to the status panel.

7. **Forecast**  
   - The user chooses forecast horizon (e.g., 60 days) and clicks **Generate**.  
   - The GUI calls `generate_forecast(...)`.  
   - Results are saved to `forecast.csv` or displayed in a `QWebEngineView` (if using Plotly HTML).  

8. **Evaluate**  
   - The user sets cross-validation parameters and clicks **Evaluate**.  
   - The GUI calls `evaluate_model(...)`.  
   - The metrics appear in a table or text field, and the user can optionally see advanced diagnostic plots.

---

## **6. Implementation Details**

### **6.1 Launching GUI from `main.py`**

```python
# main.py
import sys
from gui import start_gui
# ... other imports ...

def run_cli():
    # Existing CLI logic from Phase 1
    pass

def main():
    if "--gui" in sys.argv:
        start_gui()
    else:
        run_cli()

if __name__ == "__main__":
    main()
```

### **6.2 Example GUI Skeleton (PyQt)**

```python
# gui.py (high-level sketch)
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, QPushButton, QLabel, QFileDialog

# Import your module functions
from data_ingestion import load_data
from data_cleaning import handle_missing_values, handle_outliers
# ... etc.

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Forecasting GUI")
        self.setGeometry(100, 100, 800, 600)

        self.tabs = QTabWidget()
        
        # Tab 1: Data
        self.tab_data = QWidget()
        self.setup_tab_data()
        
        # Tab 2: Clean
        self.tab_clean = QWidget()
        self.setup_tab_clean()

        # Add tabs to widget
        self.tabs.addTab(self.tab_data, "Data")
        self.tabs.addTab(self.tab_clean, "Clean")
        # ... more tabs: Indicators, Train, Forecast, Evaluate ...
        
        self.setCentralWidget(self.tabs)

    def setup_tab_data(self):
        layout = QVBoxLayout()
        load_button = QPushButton("Load Data")
        load_button.clicked.connect(self.load_data_clicked)
        layout.addWidget(load_button)
        self.tab_data.setLayout(layout)
    
    def load_data_clicked(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Data File", "", "CSV Files (*.csv)")
        if file_path:
            # Example usage
            self.df = load_data(file_path, "ds", "y")
            # Show a message or preview data
            print(f"Loaded data with {len(self.df)} rows.")

    def setup_tab_clean(self):
        layout = QVBoxLayout()
        clean_button = QPushButton("Clean Data")
        clean_button.clicked.connect(self.clean_data_clicked)
        layout.addWidget(clean_button)
        self.tab_clean.setLayout(layout)
    
    def clean_data_clicked(self):
        if hasattr(self, "df"):
            self.df = handle_missing_values(self.df, method='drop', target_col='y')
            self.df = handle_outliers(self.df, method='zscore', target_col='y')
            print("Data cleaned. Updated row count:", len(self.df))
        else:
            print("No data to clean yet!")

def start_gui():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
```

*(Note: This code snippet is purely illustrative. You will adapt it to your project’s actual structure and naming.)*

---

## **7. Styling and Professional Appearance**

1. **Themes / Stylesheets**  
   - Use Qt Stylesheets or a **QDarkStyle** plugin for modern, polished aesthetics.  
   - Maintain consistent color themes across all tabs.

2. **Icons & Branding**  
   - Add an application icon and tab icons to enhance the professional look.  
   - Use consistent iconography to represent actions like “Load,” “Clean,” “Train,” etc.

3. **Validation & Error Handling**  
   - Provide user-friendly pop-up dialogs or status bar messages if something goes wrong (e.g., missing columns).

---

## **8. Future Extensions**

1. **Multiple Windows**  
   - Potentially add a separate “advanced settings” window for user-specified advanced configurations.  
2. **Report Generation**  
   - Automate creation of PDF or HTML reports that combine text, metrics, and charts.  
3. **Plugin System**  
   - Let advanced users create custom cleaning or indicator plugins that the GUI can discover and list dynamically.

---

## **Summary**

- **Goal**: Build a **native desktop application** that acts as the front end to your existing CLI-based forecasting pipeline.  
- **Approach**: Integrate **PyQt** (or an equivalent framework) for professional, cross-platform UIs.  
- **Flow**: Each step of the pipeline (data loading, cleaning, indicators, training, forecasting, evaluation) is exposed in **tabs** or **pages** of the GUI, invoking the same functions as the CLI.  
- **Result**: Users can now choose between a CLI workflow (Phase 1) and a graphical workflow (Phase 2), both powered by the same backend logic.

With this **Phase 2 GUI Plan**, your forecasting tool can reach a broader user base—those who prefer a **point-and-click** interface—while retaining the advanced features, modular architecture, and visual outputs developed in Phase 1.